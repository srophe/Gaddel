<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron"
  xmlns:srophe="https://srophe.app">

  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI Customization for Syriaca.org Place Data</title>
        <editor role="creator" ref="http://syriaca.org/documentation/editors.xml#dschwartz">Daniel
          L. Schwartz</editor>
      </titleStmt>
      <editionStmt>
        <edition n="1"><date>2025</date></edition>
      </editionStmt>
      <publicationStmt>
        <authority>Syriaca.org: The Syriac Reference Portal</authority>
        <availability>
          <licence target="http://creativecommons.org/licenses/by/3.0/">
            <p>Distributed under a Creative Commons Attribution 3.0 Unported License.</p>
            <p>The code examples contained in <gi>exemplum</gi> elements below come from Syriaca.org
              projects that have been distributed under a Creative Commons Attribution 3.0 Unported
              License. Used by permission.</p>
            <p>The comments on element and attribute use contained in <gi>remarks</gi> elements
              below share some text with other Syriaca.org documentation distributed under a
              Creative Commons Attributiion 3.0 Unported License. This documentation can be found at
              various links available here: <ref
                target="http://syriaca.org/documentation/index.html"
                >http://syriaca.org/documentation/index.html</ref> Used by permission. </p>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>This ODD provides a customization of the TEI P5 All. It is the third link in an ODD chain
          and uses the <title
            ref="https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/schemas/syriacaAll.compiled.odd"
            > TEI Customization for Syriaca.org</title> as its source. </p>
      </sourceDesc>
    </fileDesc>
    <profileDesc>
      <!-- Instructions for processing the Syriaca.org chained ODD in oXygen.
        - First, be sure that schemaSpec/@source in this document points to "syriacaAll.compiled.odd".
        - Then process this ODD file into a compiled ODD using the transformation scenario "ODD to Compiled ODD".
          - Save this as syriacaPlaces.compiled.odd and then delete the @start attribute from tei:schemaSpec.
          - This compiled ODD (without a tei:schemaSpec/@start attribute) will be the starting point for the next step in the chained ODD.
        - This compiled ODD can also be used to generate a .rng file against which you can validate a TEI document. 
          - You generate this file using the transformation scenario "TEI ODD to RELAX NG XML".
          - After you have generated the Relax NG, you need to add xmlns:srophe="https://srophe.app" to the grammar element at the top of that file. -->
    </profileDesc>
  </teiHeader>


  <text>
    <body>
      <opener>This version of the encoding guidelines for <ref target="https://syriaca.org/geo"
            ><title>The Syriac Gazetteer</title></ref> were drafted in 2025 by David A. Michelson,
        William L. Potter, and Daniel L. Schwartz. These guidelines are part of an ongoing community
        effort to develop uniform good practice in describing geographic data using TEI XML. These
        guidelines remain under development and contributions are welcome via pull requests or
        issues submitted to the <ref
          target="https://github.com/srophe/Gaddel/tree/main/documentation/schemas">GitHub
          repository</ref> hosted by <ref target="http://syriaca.org">Syriaca.org</ref>. They are
        licensced under a <ref target="https://creativecommons.org/licenses/by/4.0/">Creative
          Commons Attribution 4.0 International license</ref>. Users may cite the guidelines in this
        way: David A. Michelson, et. al., eds. <title>The Syriac Gazetteer: TEI P5 Customization and
          Encoding Guidelines</title> (Syriaca.org: 2025), <ref
          target="https://github.com/srophe/Gaddel/blob/main/documentation/schemas/syriacaPlaces.odd"
          >https://github.com/srophe/Gaddel/blob/main/documentation/schemas/syriacaPlaces.odd</ref>.
        <!-- Need to update URL to production URL? -->
      </opener>

      <divGen type="toc" xml:id="toc"/>

      <div xml:id="documentatiuon">
        <head>The Syriac Gazetteer: TEI P5 Customization and Encoding Guidelines</head>
        <div xml:id="introduction">
          <head>Introduction</head>
          <p>Welcome to the encoding guidelines for the third edition of <title>The Syriac
              Gazetteer</title> (hereafter <title>TSG</title>). <title>TSG</title> is a geographical
            reference work published by <ref target="https://syriaca.org"><title>Syriaca.org: The
                Syriac Reference Portal</title></ref> for places relevant to Syriac studies. These
            guidelines describe the methodology used to create <ref target="https://www.tei-c.org"
              >TEI</ref> XML files for encoding Syriac geographic data according to the schema
            implemented by Syriaca.org. We have chosen to use the TEI guidelines because they allow
            a high level of detail, citation of sources, and flexibility for representing prose
            data. We anticipate that this schema can be easily adapted for other historical
            gazetteers and we invite comments and suggestions for improvement. </p>
        </div>
        <div xml:id="acknowledgements">
          <head>Acknowledgements</head>
          <p>This present document reuses and adapts guidelines published as <ref
              target="https://tei-c.org/release/doc/tei-p5-doc/en/html/index.html"><title>TEI:
                Guidelines for Electronic Text Encoding and Interchange</title></ref> in the P5
            release, version 4.9.0 as updated on 24th January 2025 (revision f73186978). The TEI
            guideliens are reused here under the terms of the <ref
              target="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0
              Unported License</ref>. An initial schema and documentation for the first edition of
              <title>The Syriac Gazetteer</title> was designed in 2012-2014 by Tom Elliott, Thomas
            Carlson, Daniel L. Schwartz, Winona Salesky, and David A. Michelson. In 2019, Michelle
            P. Taylor, William L. Potter, and David A. Michelson prepared written documentation for
            the second edition. Portions of the documentation from the first two editions have been
            reused below under the terms of the <ref
              target="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0
              International license</ref>. The current document represents guidelines for the third
            edition of <title>The Syriac Gazetteer</title>. </p>
        </div>
        <div xml:id="phraselevel">
          <head>General Principles</head>
          <!-- WLP: Either here or in another section, I wonder if we eventually want a paragraph saying that the Gazetteer documentation assumes familiarity with Syriaca-wide principles like the use of URIs to identify conceptual entities and other syriaca-wide encoding conventions that then links to documentation pages for those principles? -->
          <p><title>TSG</title> is a geographical reference work published by Syriaca.org to
            identify and describe places relevant to Syriac studies. The editors interpret “places
            relevant to Syriac Studies” in a maximal rather than restrictive sense, thus
              <title>TSG</title> is meant to include places named in Syriac texts (such as <ref
              target="https://syriaca.org/place/326">Ḥarqel — ܚܪܩܠ</ref>), places interesting to
            historians who work on Syriac texts (such as <ref target="https://syriaca.org/place/77"
              >Dura-Europos</ref>), places where scholarship on Syriac is being produced (such as
              <ref target="https://syriaca.org/place/593">Japan</ref>), and contemporary places
            relevant to the modern Syriac heritage communities. There are no chronological or
            spatial constraints on what may be included in <title>TSG</title>. At least in theory,
            any type or size of place could be represented in the geographic database, from large
            empires to single churches or a particular named city gate. Map coordinates are provided
            for some places, but the database also includes places which are not located or even
            locatable. Mythological and other ahistorical places are also included in the
            database.</p>
          <p>The concept of distinct place is the distinguishing criterion for each entry in
              <title>TSG</title>. Each record in <title>TSG</title> represents a place that can be
            disambiguated from other places. Each place is a unique conceptual entity with a mental
            existence related to, but not reducible to, its physical manifestation. Each place is
            assigned a unique indentifier (a URI, i.e. Uniform Resource Identifier) of the format:
              <egXML xmlns="http://www.tei-c.org/ns/Examples"
            >http://syriaca.org/place/{\d+}</egXML>.</p>
          <p>When considering the TEI XML schema created for <title>TSG</title>, it is essential to
            note that we have customized these guidelines specifically for use in digitally encoding
            geographic data related to the field of Syriac studies. Due to this specialized use,
            these guidelines do not include all possible TEI XML features which might be employed
            for historical geography in general. Moreover, because the main language of
              <title>TSG</title> is English, these guidelines assume that each file will designate
            English as its main language.</p>
          <p>We have followed the guidelines below with the assumption that the resulting XML files
            for the <ref target="https://syriaca.org/geo"><title>The Syriac Gazetteer</title></ref>
            will be displayed using the custom <title>Gaddel App</title> developed by Syriaca.org
            and The Digital Lab at Vanderbilt University. We have also made an effort to ensure (as
            much as possible) that our data will be easily serialized to conform to the data model
            developed by the <ref target="https://pleiades.stoa.org/"><title>Pleiades</title></ref>
            project, a community-built gazetteer for the field of ancient studies, and to the <ref
              target="https://pelagios.org/"><title>Pelagios Network</title>'s</ref> implementation
            of Linked Open Data principles.</p>
          <p>For a more detailed discussion of the data model and architecture of Syraica.org,
            readers are encouraged to consult the following technical publication: David A.
            Michelson, “Using Linked Open Data to Model Cultural Heritage Information: The Research
            Questions and Data Structures of the Syriaca.Org Knowledge Graph,” in <title>Linked Open
              Data for the Ancient Mediterranean: Structures, Practices, Prospects</title>, edited
            by Sarah E. Bond, Paul Dilley, and Ryan Horne, <title>ISAW Papers</title> 20 (2021),
              <ref target="http://hdl.handle.net/2333.1/69p8d8cc"
              >http://hdl.handle.net/2333.1/69p8d8cc</ref>. </p>
        </div>
        <div>
          <head>Required Record Structure</head>
          <p>This section presents, in document order, the elements and structure required in each
            record.</p>
          <div xml:id="rootElement">
            <head>The TEI Root Element</head>
            <p>The <gi>TEI</gi> root element should contain the same attribute values in every
                <title>TSG</title> record. These are namespace declarations and a language
              declaration. The <gi>TEI</gi> root element also must always contain the same two child
              elements: <gi>teiHeader</gi> and <gi>text</gi>.</p>
          </div>
          <div xml:id="header">
            <head>The TEI Header</head>
            <p>The <gi>teiHeader</gi> element contains metadata about title, authorship, copyright,
              and licensing of the data in the record. The <gi>teiHeader</gi> in <title>TSG</title>
              records follows the same guidelines for all Syriaca.org publications. These guidelines
              will be published elsewhere on the Syriaca.org documentation page.</p>
          </div>
          <div xml:id="placeRecordStructure">
            <head>Structure of a Place Record</head>
          </div>
          <div xml:id="listPlace">
            <head>Containing Element</head>
            <p>All geographic data in each <title>TSG</title> record must be contained in a tree
              structure of the following elements <code>/TEI/text/body/listPlace</code>. The
                <gi>listPlace</gi> element must contain a <gi>place</gi> element and may contain a
                <gi>listRelation</gi> element.</p>
            <div xml:id="place">
              <head>Place</head>
              <p>Except for information about related entities, all geographic data is encoded in a
                single <gi>place</gi> element. This <gi>place</gi> element must have @type and @ana
                attributes
                <!-- WLP: TBD: required and allowed children elements? Also add or reference a table of the place types and their taxonomy URIs -->
              </p>
              <!-- WLP: I think the conceptual bit about 'what' a place is, identity, etc. should go in an above section that gives the methodological/theoretical fundamentals of the TSG? -->

              <div xml:id="placeName">
                <head>Place Names</head>
                <p>Place names are essential for identifying and disambiguating individual places.
                  Every record must have at least one <gi>placeName</gi> element, and may have any
                  number. The text node of this element contains a name by which the place is known.
                  Multiple name variants can be added; each should be in a separate
                    <gi>placeName</gi>. Name variants may be recorded for any language and must be
                  tagged with the corresponding ISO language code with an @xml:lang attribute. .
                  Each record must have at least one place name in English.
                  <!--  If necessary, the author may craft a prose description as a place name.--></p>
                <!-- TBD: maybe reference a standard documentation section or page for Syriaca's lang code usage? -->
                <p>Additionally, <gi>placeName</gi> elements must have a unique @xml:id attribute of
                  the form <code>name\d+-\d+</code>. The first digits derive from the numerical
                  portion of the Syriaca URI for the place, and the latter is a sequential integer:
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <placeName xml:id="name78-6" xml:lang="ar" source="#bib78-4">الرها</placeName>
                  </egXML> Finally, as seen in the preceding example, all <gi>placeName</gi>
                  elements must indicate the source of the name form either via a @source attribute
                  or a @resp attribute. The @source attribute is used...
                  <!-- WLP: I think we should have a general section on sourcing information, which we then refer to throughout for elements that require a source/resp (placeName, desc, etc.) -->
                </p>
                <div xml:id="headword">
                  <head>Syriaca Headwords</head>
                  <!-- WLP: note that although the v2 guidelines said there must be an en headword, the schema only constrains for the existence of at least one name tagged as a headword-->
                  <p>At least one <gi>placeName</gi> element must be tagged as a Syriaca Headword
                    using a @srophe:tags attribute with the value of
                      <quote>#syriaca-headword</quote>. As the headwords are used as preferred
                    labels and for alphabetization in search/brose results, at least one English
                    place name should be tagged as a headword. At most one headword per language may
                    be defined. <egXML xmlns="http://www.tei-c.org/ns/Examples">
                      <placeName source="#bib78-2 #bib78-5" xml:id="name78-1" xml:lang="en"
                        srophe:tags="#syriaca-headword">Edessa</placeName>
                      <placeName xml:id="name78-2" xml:lang="en" source="#bib78-2 #bib78-5 #bib78-7"
                        >Urfa</placeName>
                      <placeName resp="http://syriaca.org" xml:id="name78-3" xml:lang="syr"
                        srophe:tags="#syriaca-headword">ܐܘܪܗܝ</placeName>
                    </egXML>
                  </p>
                </div>
              </div>
              <div xml:id="desc">
                <head>Descriptions</head>
                <p>TBD</p>
                <div xml:id="abstracs">
                  <head>Abstracts</head>
                </div>
              </div>
              <div xml:id="location">
                <head>Locations</head>
                <p>TBD</p>
                <!-- WLP: add sub-sections for GPS vs. relative? -->
              </div>
              <div xml:id="event">
                <head>Events</head>
                <p>TBD</p>
                <!-- WLP: add sub-sections for attestations and other events -->
              </div>
              <div xml:id="state">
                <head>States</head>
                <p>TBD</p>
                <!-- WLP: add sub-sections for existence states and confession states -->
              </div>
              <div xml:id="note">
                <head>note</head>
                <p>TBD</p>
                <!-- WLP: add sub-sections for the note types? Or are these at the syriaca-all level? We can put them here for now, and just copy in from the v2 encoding guidelines -->
              </div>
              <div xml:id="idno">
                <head>idno</head>
                <p>TBD</p>
              </div>
              <div xml:id="bibl">
                <head>bibl</head>
                <p>TBD</p>
              </div>
            </div>
            <div xml:id="listrelation">
              <head>Related Entities</head>
              <p>TBD</p>
            </div>
          </div>
        </div>
      </div>

      <div xml:id="schema">
        <head><title>The Syriac Gazetteer</title> Schema Customization</head>
        <schemaSpec ident="syriacaPlaces" prefix="tei_" source="syriacaAll.compiled.odd"
          xml:lang="en"
          defaultExceptions="http://www.tei-c.org/ns/1.0 teix:egXML​ http://www.example.org/ns/">
          <moduleRef key="tei"/>
          <moduleRef key="certainty" include="precision"/>
          <moduleRef key="core"
            include="abbr author bibl biblScope choice citedRange date desc editor expan foreign listBibl measure name note orig p ptr quote reg ref resp respStmt rs title"/>
          <moduleRef key="header"
            include="authority availability catDesc category change classDecl edition editionStmt editorialDecl encodingDesc fileDesc funder idno langUsage licence principal profileDesc publicationStmt revisionDesc seriesStmt sourceDesc sponsor taxonomy teiHeader titleStmt"/>
          <moduleRef key="linking" include="link"/>
          <moduleRef key="namesdates"
            include="event geo listPlace listRelation location offset persName place placeName relation state"/>
          <moduleRef key="tagdocs" include="gi"/>
          <moduleRef key="textstructure" include="TEI body text"/>
          <classRef key="att.global.analytic"/>
          <classRef key="att.global.change"/>



          <elementSpec ident="bibl" module="core" mode="change">
            <constraintSpec ident="xmlID-on-bibl" scheme="schematron">
              <constraint>
                <sch:rule context="//tei:text//tei:place/child::tei:bibl">
                  <sch:let name="docURIno"
                    value="replace(//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/text(), '.+?(\d+).+', '$1')"/>
                  <sch:let name="id" value="@xml:id"/>
                  <sch:assert test="matches(./@xml:id, concat('bib', $docURIno, '-', '\d+$'))"> The
                    required @xml:id must be 'bib<sch:value-of select="$docURIno"/>-{\d+}' (where
                    {\d+} is a number). </sch:assert>
                  <sch:report test="preceding-sibling::element()[@xml:id = $id]">This @xml:id is
                    already in use.</sch:report>
                </sch:rule>
                <sch:rule context="tei:text//tei:bibl[not(parent::tei:place)]">
                  <sch:report test="@xml:id">This &lt;bibl&gt; cannot contain an
                    @xml:id.</sch:report>
                </sch:rule>
              </constraint>
            </constraintSpec>
          </elementSpec>



          <elementSpec ident="biblScope" module="core" mode="change">
            <constraintSpec ident="biblScope-in-seriesStmt" scheme="schematron">
              <constraint>
                <sch:rule context="tei:seriesStmt/tei:biblScope/@unit">
                  <sch:assert test=". = 'volume'">The @unit must be "volume".</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="unit" mode="change" usage="req">
                <valList type="closed" mode="replace">
                  <valItem ident="volume"/>
                </valList>
              </attDef>
              <attDef ident="n" mode="change" usage="req"/>
            </attList>
          </elementSpec>



          <elementSpec ident="body" module="textstructure" mode="change">
            <content>
              <elementRef key="listPlace" minOccurs="1" maxOccurs="1"/>
            </content>
            <remarks mode="replace">
              <p>The <gi>body</gi> element of a Syriaca.org place record must contain a
                  <gi>listPlace</gi> element. </p>
            </remarks>
          </elementSpec>



          <elementSpec ident="date" module="namesdates" mode="change">
            <attList>
              <attDef ident="resp" mode="delete"/>
              <attDef ident="source" mode="delete"/>
            </attList>
          </elementSpec>




          <elementSpec ident="desc" module="core" mode="change">
            <constraintSpec ident="documentation-on-place-desc" scheme="schematron">
              <constraint>
                <sch:rule context="tei:place/tei:desc">
                  <sch:report test="@resp and @source">Only one of the attributes @resp and @source
                    may be supplied.</sch:report>
                </sch:rule>
                <sch:rule context="tei:location/tei:desc">
                  <sch:report test="@resp or @source">Documentation using @resp or @source should go
                    on the parent &lt;location&gt; element.</sch:report>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="place-desc-child-quote" scheme="schematron">
              <constraint>
                <sch:rule context="tei:place/tei:desc[not(tei:quote)]">
                  <sch:assert test="@resp or @source">One of the attributes @resp or @source must be
                    supplied.</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="confession-desc" scheme="schematron">
              <constraint>
                <sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" queryBinding="xslt2">
                  <sch:ns uri="http://www.tei-c.org/ns/1.0" prefix="tei"/>
                  <sch:ns uri="http://www.w3.org/1999/02/22-rdf-syntax-ns#" prefix="rdf"/>
                  <sch:ns uri="http://www.w3.org/2004/02/skos/core#" prefix="skos"/>
                  <sch:pattern>
                    <sch:rule context="//tei:state[@type='confession']/tei:desc">
                      <sch:let name="confessionDoc"
                        value="doc('https://raw.githubusercontent.com/srophe/srophe-eXist-app/master/documentation/confessions.xml')"/>
                      <sch:let name="stateRefPart"
                        value="substring-after(parent::tei:state/@ref, '/taxonomy/')"/>
                      <sch:let name="descToRefPart" value="lower-case(replace(., ' ', '-'))"/>
                      <sch:let name="descTokens" value="tokenize(., ' ')"/>
                      <sch:assert test="parent::tei:state/@type='confession'">A &lt;desc&gt; element
                        can only be used when parent &lt;state&gt; element has
                        @type="confession"</sch:assert>
                      <sch:assert test="$stateRefPart = $descToRefPart"> The text node in the
                        &lt;desc&gt; element must correspond to the @ref attribute on the parent
                        &lt;state&gt; element: <sch:value-of select="parent::tei:state/@ref"/> Use
                        the portion of the URI following "taxonomy/" and capitalize the first letter
                        of each word. </sch:assert>
                      <sch:assert
                        test="every $i in $descTokens satisfies ($i = ('the', 'of') or matches($i, '^[A-Z].*'))"
                        > Please capitalize the first letter of each word, except for "the" and
                        "of". </sch:assert>
                    </sch:rule>
                  </sch:pattern>
                </sch:schema>
              </constraint>
            </constraintSpec>
          </elementSpec>




          <elementSpec ident="event" module="namesdates" mode="change">
            <attList>
              <attDef ident="type" mode="change" usage="req">
                <desc>The <gi>event</gi> element requires a <att>type</att> attribute.</desc>
                <valList type="closed" mode="replace">
                  <valItem ident="attestation">
                    <desc>An event that attests to the entity described in the document</desc>
                  </valItem>
                  <valItem ident="other">
                    <desc>Any event that does something other than attest to the entity described in
                      the document</desc>
                  </valItem>
                </valList>
              </attDef>
            </attList>
          </elementSpec>



          <elementSpec ident="idno" module="header" mode="change"> </elementSpec>



          <elementSpec ident="listPlace" module="namesdates" mode="change">
            <classes mode="change">
              <memberOf key="att.global" mode="delete"/>
              <memberOf key="att.typed" mode="delete"/>
              <memberOf key="att.sortable" mode="delete"/>
            </classes>
            <content>
              <sequence preserveOrder="true">
                <elementRef key="place" minOccurs="1" maxOccurs="1"/>
                <elementRef key="listRelation" minOccurs="0" maxOccurs="1"/>
              </sequence>
            </content>
            <remarks mode="add">
              <p>The <gi>listPlace</gi> element of a place record must contain a <att>place</att>
                element and may contain a <gi>listRelation</gi> element. </p>
            </remarks>
          </elementSpec>



          <elementSpec ident="location" module="namesdates" mode="change">
            <!--<classes mode="change">
            <memberOf key="att.global.rendition" mode="delete"/><!-\- not deleted -\->
            <memberOf key="att.global.linking" mode="delete"/><!-\- not deleted -\->
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            
          </classes>-->
            <content>
              <alternate>
                <elementRef key="geo"/>
                <elementRef key="desc"/>
              </alternate>
            </content>
            <constraintSpec ident="location-children" scheme="schematron">
              <constraint>
                <sch:rule context="//tei:location[@type='gps']">
                  <sch:assert test="./tei:geo"> A &lt;location&gt; element of @type="gps" requires a
                    child element &lt;geo&gt;. </sch:assert>
                </sch:rule>
                <sch:rule context="//tei:location[@type='relative']">
                  <sch:assert test="./tei:desc"> A &lt;location&gt; element of @type="relative"
                    requires a child elements: &lt;desc&gt;. </sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="documentation-on-location" scheme="schematron">
              <constraint>
                <sch:rule context="//tei:place/tei:location">
                  <sch:report test="@source and @resp">Only one of the attributes @resp and @source
                    may be supplied.</sch:report>
                </sch:rule>
                <sch:rule context="tei:place/tei:location[not(tei:quote)]">
                  <sch:assert test="@resp or @source">One of the attributes @resp or @source must be
                    supplied.</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="subtype-on-location" scheme="schematron">
              <constraint>
                <sch:rule context="tei:location[@subtype='preferred']">
                  <sch:report test="not(@type='gps')">The attribute @subtype with value "preferred"
                    can only be used with @type="gps".</sch:report>
                  <sch:report
                    test=".[@type='gps'][@subtype='preferred'][preceding-sibling::tei:location[@type='gps'][@subtype='preferred']]"
                    > The data already contains a preferred gps location and only one is
                    allowed.</sch:report>
                </sch:rule>
                <sch:rule
                  context="tei:location[count(../tei:location[@type='gps']) > 1][@type='gps']">
                  <sch:assert test="@subtype"> When there are two or more gps locations, the
                    &lt;location&gt; element must contain a @subtype attribute.</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="type" mode="change" usage="req">
                <valList mode="replace" type="closed">
                  <valItem ident="gps"/>
                  <valItem ident="relative"/>
                </valList>
              </attDef>
              <attDef ident="subtype" mode="change">
                <valList mode="replace" type="closed">
                  <valItem ident="preferred">
                    <desc>Indicates a preferred location when the data contains multiple
                      locations</desc>
                  </valItem>
                  <valItem ident="alternate">
                    <desc>Indicates a non-preferred location when the data contains multiple
                      location</desc>
                  </valItem>
                </valList>
              </attDef>
              <attDef ident="source" mode="change">
                <desc> In most cases the <gi>location</gi> element will have a <att>source</att>
                  attribute pointing to the <gi>bibl</gi> element that is the source of that
                  location information. In instances were the location information has been
                  collected by a Syriaca.org contributor but is not attested in print, a
                    <att>resp</att> is used with a value of 'http://syriaca.org'. </desc>
              </attDef>
            </attList>
          </elementSpec>



          <elementSpec ident="measure" module="core" mode="change">
            <!--<classes mode="change"><!-\- all deleted -\->
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.global.rendition" mode="delete"/>
            <memberOf key="att.global.linking" mode="delete"/>
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            <memberOf key="att.global.responsibility" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>-->
            <attList>
              <attDef ident="type" mode="delete"/>
            </attList>
          </elementSpec>



          <elementSpec ident="note" module="core" mode="change">
            <constraintSpec ident="note-type-deprecation" scheme="schematron">
              <!-- Changes to relation elements will require this to change. -->
              <constraint>
                <sch:rule context="//tei:body//tei:note[@type='deprecation']">
                  <sch:assert test="./@target"> A &lt;note&gt; element of @type="deprecation" must
                    have a @target attribute. </sch:assert>
                </sch:rule>
                <sch:rule context="//tei:text//tei:note[@type='deprecation']/@target">
                  <sch:let name="nameIDs" value="//tei:place/tei:placeName/@xml:id"/>
                  <sch:let name="IDvalues" value="for $i in $nameIDs return concat('#', $i)"/>
                  <sch:assert test="every $i in tokenize(., ' ') satisfies $i = $IDvalues"> This
                    @target attribute on &lt;note&gt; of @type="deprecation" can take one or more of
                    the following value separated by a space: <sch:value-of
                      select="string-join($IDvalues, ' | ')"/>. </sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="corresp" mode="delete"/>
            </attList>
          </elementSpec>



          <elementSpec ident="offset" module="namesdates" mode="change">
            <!--<classes mode="change"><!-\- all deleted -\->
            <memberOf key="att.datable" mode="delete"/>
            <memberOf key="att.datable.w3c" mode="delete"/>
            
            <memberOf key="att.datable.custom" mode="delete"/>
            
            <memberOf key="att.global" mode="delete"/>
            <memberOf key="att.global.rendition" mode="delete"/>
            <memberOf key="att.global.linking" mode="delete"/>
            <memberOf key="att.global.analytic" mode="delete"/>
            
            <memberOf key="att.global.change" mode="delete"/>
            <memberOf key="att.global.responsibility" mode="delete"/>
            <memberOf key="att.global.source" mode="delete"/>
            <memberOf key="att.naming" mode="delete"/>
            <memberOf key="att.typed" mode="delete"/>
          </classes>-->
            <!--<attList>
            
            <attDef ident="ref" mode="change" usage="req"/>
          </attList>-->
          </elementSpec>




          <elementSpec ident="persName" module="namesdates" mode="change">
            <classes mode="change">
              <memberOf key="att.global" mode="delete"/>
            </classes>
            <attList>
              <attDef ident="sort" mode="delete"/>
              <attDef ident="role" mode="delete"/>
              <attDef ident="key" mode="delete"/>
              <attDef ident="srophe:tags" mode="delete"/>
            </attList>
          </elementSpec>



          <elementSpec ident="place" module="namesdates" mode="change">
            <classes mode="change">
              <memberOf key="att.sortable" mode="delete"/>
            </classes>
            <content>
              <sequence preserveOrder="true">
                <elementRef key="placeName" minOccurs="1" maxOccurs="unbounded"/>
                <elementRef key="desc" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="location" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="event" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="state" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="idno" minOccurs="1" maxOccurs="unbounded"/>
                <elementRef key="bibl" minOccurs="1" maxOccurs="unbounded"/>
              </sequence>
            </content>
            <constraintSpec ident="person-abstract-req" scheme="schematron">
              <constraint>
                <sch:rule context="tei:place">
                  <sch:assert test="tei:desc[@type='abstract']">Every place record must have at
                    least one &lt;desc&gt; @type="abstract".</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="subtype" mode="delete"/>
              <attDef ident="type" mode="replace" usage="req">
                <valList type="closed" mode="replace">
                  <!-- This should be migrated to LOD when possible -->
                  <valItem ident="building">
                    <desc>A construction for which there is no narrower category, such as a church
                      or mosque. Examples of this type include palaces and named city gates.</desc>
                  </valItem>
                  <valItem ident="cemetery">
                    <desc>A place for human burial.</desc>
                  </valItem>
                  <valItem ident="church">
                    <desc>A place regularly designated for Christian worship.</desc>
                  </valItem>
                  <valItem ident="composite">
                    <desc>A named place concept which merges multiple distinct place types, such as
                      a city and a diocese. More specific types are preferred.</desc>
                  </valItem>
                  <valItem ident="designated-space">
                    <desc>An area with artificial boundaries which is not necessarily built up, such
                      as a cemetery, town square, or polo ground.</desc>
                  </valItem>
                  <valItem ident="diocese">
                    <desc>An ecclesiastical province governed by a bishop, archbishop, or
                      metropolitan.</desc>
                  </valItem>
                  <valItem ident="fortification">
                    <desc>A military outpost such as a fort or a castle.</desc>
                  </valItem>
                  <valItem ident="hospice">
                    <desc>A hospital or hostel.</desc>
                  </valItem>
                  <valItem ident="island">
                    <desc>A land-mass smaller than a continent surrounded on all sides by
                      water.</desc>
                  </valItem>
                  <valItem ident="madrasa">
                    <desc>A building or space designated for instruction in the Islamic
                      sciences.</desc>
                  </valItem>
                  <valItem ident="monastery">
                    <desc>A whole monastic complex, including living quarters for the monks or nuns,
                      the church(es), and potentially a refectory, library, school, or other
                      part.</desc>
                  </valItem>
                  <valItem ident="mosque">
                    <desc>A building or designated space used for Muslim congregational prayers. It
                      can be part of a larger building complex.</desc>
                  </valItem>
                  <valItem ident="mountain">
                    <desc>An elevated physical feature, from Mt. Ararat down to a prominent
                      hill.</desc>
                  </valItem>
                  <valItem ident="natural-feature">
                    <desc>A natural feature for which there is no narrower category, such as a
                      mountain or open water. Examples of this type include forests and hot
                      springs.</desc>
                  </valItem>
                  <valItem ident="open-water">
                    <desc>A broad category for seas, lakes, oceans, and ponds.</desc>
                  </valItem>
                  <valItem ident="parish">
                    <desc>An ecclesiastical region below a diocese, presided over by a
                      priest.</desc>
                  </valItem>
                  <valItem ident="province">
                    <desc>A political unit subject to a "state" but larger than a city. States often
                      have multiple levels of administrative units (e.g. the late Ottoman vilayets,
                      sanjaks, kazas, and nahiyes), all of which can be indicated as a
                      "province."</desc>
                  </valItem>
                  <valItem ident="quarter">
                    <desc>A subdivision of an urban center.</desc>
                  </valItem>
                  <valItem ident="region">
                    <desc>A term indicating a geographic extent larger than a city, without a
                      corresponding politico-administrative apparatus. The size could range from a
                      small valley to an entire continent.</desc>
                  </valItem>
                  <valItem ident="residence">
                    <desc>A domestic space used for longterm living rather than a simple temporary
                      shelter.</desc>
                  </valItem>
                  <valItem ident="river">
                    <desc>A stream of water of whatever size, from the smallest creek to the Amazon.
                      Wadis are also included, even if they are not filled with water
                      year-round.</desc>
                  </valItem>
                  <valItem ident="settlement">
                    <desc>Any collection of civilian residences, from the smallest village to the
                      largest metropolis.</desc>
                  </valItem>
                  <valItem ident="state">
                    <desc>A sovereign government such as an empire, kingdom, caliphate, or
                      independent emirate.</desc>
                  </valItem>
                  <valItem ident="synagogue">
                    <desc>A building designated for use in Jewish worship.</desc>
                  </valItem>
                  <valItem ident="temple">
                    <desc>A building designated for use in pagan worship.</desc>
                  </valItem>
                  <valItem ident="unknown">
                    <desc>A place whose name is known, but what sort of place it represents is
                      unknown.</desc>
                  </valItem>
                  <valItem ident="valley">
                    <desc>A natural feature typically between two mountains or hills.</desc>
                  </valItem>
                </valList>
              </attDef>
              <attDef ident="ana" mode="change" usage="req">
                <constraintSpec ident="ana-on-place" scheme="schematron">
                  <constraint>
                    <sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"
                      queryBinding="xslt2">
                      <sch:ns uri="http://www.tei-c.org/ns/1.0" prefix="tei"/>
                      <sch:ns uri="http://www.w3.org/1999/02/22-rdf-syntax-ns#" prefix="rdf"/>
                      <sch:ns uri="http://www.w3.org/2004/02/skos/core#" prefix="skos"/>
                      <sch:pattern>
                        <sch:rule context="tei:place">
                          <sch:let name="taxonomy"
                            value="doc('https://raw.githubusercontent.com/srophe/syriaca-data/refs/heads/gaddel_development/data/taxonomy/taxonomy.rdf')"/>
                          <sch:let name="placeTypesURIs"
                            value="$taxonomy//rdf:Description[@rdf:about='http://syriaca.org/taxonomy/place-types-collection']/skos:member/@rdf:resource"/>
                          <sch:assert test="@ana = $placeTypesURIs"> This place element requires an
                            @ana attribute. The value should come from the following list. If you
                            find no appropriate concept there, please choose a keyword of your own
                            for the editors to consider: <sch:value-of
                              select="string-join($placeTypesURIs, ';  ')"/>. Please note as well
                            that the @type attribute values are also constrained and that there must
                            be agreement between @ana and @type. </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='building']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/buildings'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/buildings". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='church']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/churches'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/churches". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='composite']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/composite'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/composite". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='designated-space']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/designated-spaces'">
                            Based on the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/designated-spaces". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='diocese']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/dioceses'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/dioceses". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='fortification']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/fortifications'"> Based
                            on the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/fortifications". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='hospice']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/hospices'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/hospices". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='island']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/islands'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/islands". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='madrasa']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/madrasas'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/madrasas". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='monastery']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/monasteries'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/monasteries". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='mosque']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/mosques'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/mosques". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='mountain']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/mountains'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/mountains". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='natural-feature']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/natural-features'">
                            Based on the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/natural-features". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='open-water']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/open-water'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/open-water". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='parish']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/parishes'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/parishes". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='province']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/provinces'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/provinces". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='quarter']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/quarters'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/quarters". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='region']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/regions'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/regions". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='residence']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/residences'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/residences". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='river']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/rivers'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/rivers". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='settlement']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/settlements'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/settlements". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='state']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/states'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/states". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='synagogue']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/synagogues'"> Based on
                            the @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/synagogues". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='temple']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/temples'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/temples". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='cemetery']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/tombs'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/tombs". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='unknown']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/unknown'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/unknown". </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:place[@type='valley']/@ana">
                          <sch:assert test=". = 'http://syriaca.org/taxonomy/valleys'"> Based on the
                            @type value, this @ana value should be
                            "http://syriaca.org/taxonomy/valleys". </sch:assert>
                        </sch:rule>
                      </sch:pattern>
                    </sch:schema>
                  </constraint>
                </constraintSpec>
              </attDef>
            </attList>
            <remarks mode="add">
              <p>Within each <gi>place</gi> element will be a series of: one or more
                  <gi>placeName</gi> elements, zero or more <gi>location</gi> elements, zero or more
                  <gi>event</gi> elements, zero or more <gi>state</gi> elements, one or more
                  <gi>note</gi> description elements, one or more <gi>idno</gi> elements, and one or
                more <gi>bibl</gi> elements. </p>
            </remarks>
          </elementSpec>



          <elementSpec ident="placeName" module="namesdates" mode="change">
            <constraintSpec ident="documentation-on-placeName" scheme="schematron">
              <constraint>
                <sch:rule context="//tei:place/tei:placeName">
                  <sch:report test="@source and @resp">Only one of the attributes @resp and @source
                    may be supplied.</sch:report>
                  <sch:assert test="@resp or @source">One of the attributes @resp or @source must be
                    supplied.</sch:assert>
                </sch:rule>
                <sch:rule context="tei:place//tei:placeName[not(parent::tei:place)]">
                  <sch:report test="@source and @resp">Neither of the attributes @resp and @source
                    may be supplied.</sch:report>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="placeName-content" scheme="schematron">
              <constraint>
                <sch:rule context="tei:text//tei:place/tei:placeName">
                  <sch:assert test="string-length(.) gt 0">The &lt;placeName&gt; element cannot be
                    empty.</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <!-- This works in the schematron but not when placed into the ODD and converted to RelaxNG. There is a namespace issue I will try to troubleshoot.
            <constraintSpec ident="langHeadword" scheme="schematron">
            <constraint>
              <sch:rule context="//tei:place/tei:placeName">
                <sch:let name="langsOfHW" value="//tei:place/tei:placeName[@srophe:tags='#syriaca-headword']/@xml:lang"/>
                <sch:assert test="count(./parent::tei:place/tei:placeName[@xml:lang='en' and @srophe:tags='#syriaca-headword']) = 1">
                  There can be one and only one &lt;placeName&gt; element with the combination of @srophe:tags="#syriaca-headword" and @xml:lang="en".
                </sch:assert>
                <sch:assert test="count(distinct-values($langsOfHW)) = count($langsOfHW)">
                  There cannot be more than one headword (@srophe:tags="#syriaca-headword") per &lt;placeName&gt; with the same language (@xml:lang).
                </sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>-->
            <constraintSpec ident="xmlID-on-placeName" scheme="schematron">
              <constraint>
                <sch:rule context="tei:text/tei:place/tei:placeName">
                  <sch:let name="docURIno"
                    value="replace(//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/text(), '.+?(\d+).+', '$1')"/>
                  <sch:let name="id" value="@xml:id"/>
                  <sch:assert test="matches(./@xml:id, concat('name', $docURIno, '-', '\d+$'))"> The
                    required @xml:id must be 'name<sch:value-of select="$docURIno"/>-{\d+$}' (where
                    {\d+$} is a number). </sch:assert>
                  <sch:report test="preceding-sibling::element()[@xml:id = $id]">This @xml:id is
                    already in use.</sch:report>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="xmlLang-on-placeName" scheme="schematron">
              <constraint>
                <sch:rule context="tei:text//tei:place/tei:placeName">
                  <sch:assert test="./@xml:lang">A &lt;placeName&gt; element that is the direct
                    child of the &lt;place&gt; element must have an @xml:lang
                    attribute.</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="xml:id" mode="change">
                <desc> The <gi>placeName</gi> element requires an <att>xml:id</att> attribute whose
                  value is the concatenation of "name", the Syriaca.org ID number of this place
                  (i.e. the last element of the URI), a ‘-’, and the number of this name element in
                  order. </desc>
              </attDef>
              <attDef ident="xml:lang" mode="change">
                <desc> The language of the name should be indicated in an <att>xml:lang</att>
                  attribute of the <gi>placeName</gi> element, whose value is derived from the the
                    <ref target="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO-639-1
                    or ISO-639-2 standards</ref>. In particular, "en" should be used for "English",
                  "ar" for "Arabic", and "syr" for Syriac. Syriaca.org is not using "syc" for Syriac
                  to avoid the judgment of what constitutes "classical." In the case of vocalized
                  Syriac, the <att>xml:lang</att> attribute should be augmented with a script
                  indication: either "-Syrj" to indicate West Syrian vocalization or "-Syrn" to
                  indicate East Syrian vocalization. Thus the <att>xml:lang</att> attribute will
                  have a value of "syr-Syrj" for vocalized Western Syriac and "syr-Syrn" for
                  vocalized Eastern Syriac. The <att>xml:lang</att> attribute for an unvocalized
                  Syriac name form, such as Syriaca.org’s headword form, should be simply "syr".
                </desc>
              </attDef>
            </attList>
          </elementSpec>





          <elementSpec ident="relation" module="namesdates" mode="change">
            <constraintSpec ident="documentation-on-relation" scheme="schematron">
              <constraint>
                <sch:rule context="tei:text//tei:relation">
                  <sch:report test="@source and @resp">Only one of the attributes @resp and @source
                    may be supplied.</sch:report>
                  <sch:assert test="@resp or @source">One of the attributes @resp or @source must be
                    supplied.</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="act-pass-mutual-on-relation" scheme="schematron">
              <constraint>
                <sch:rule
                  context="tei:text//tei:relation/@mutual | tei:text//tei:relation/@active | tei:text//tei:relation/@passive"
                  role="warning">
                  <sch:let name="placeIndex"
                    value="doc('https://raw.githubusercontent.com/srophe/syriaca/refs/heads/main/documentation/indexes/places.xml')"/>
                  <sch:let name="placeURIs" value="$placeIndex//tei:place/@ref"/>
                  <sch:assert test="every $i in tokenize(., ' ') satisfies $i = $placeURIs"> This
                    attribute contains one or more place URIs not in use in Syriaca.org data. Note
                    that all place URIs take the form 'http://syriaca.org/place/{\d+?}' (where
                    {\d+?} is a number). </sch:assert>
                </sch:rule>
                <sch:rule context="tei:text//tei:relation/@mutual | tei:text//tei:relation/@active">
                  <sch:let name="docURI"
                    value="//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/substring-before(., '/tei')"/>
                  <sch:assert test="contains(., $docURI)"> This attribute must contain the URI for
                    this document's place: <sch:value-of select="$docURI"/>. </sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="atts-on-relation" scheme="schematron">
              <constraint>
                <sch:rule context="tei:text//tei:relation[@type='disambiguation']">
                  <sch:assert
                    test="@ref='http://syriaca.org/taxonomy/conceptually-related' or @ref='http://syriaca.org/taxonomy/co-located' or @ref='http://syriaca.org/taxonomy/not-to-be-confused-with' or @ref='http://syriaca.org/taxonomy/share-a-name'"
                    > With @type="disambiguation", the @ref attribute must be one of the following
                    "http://syriaca.org/taxonomy/conceptually-related",
                    "http://syriaca.org/taxonomy/co-located",
                    "http://syriaca.org/taxonomy/not-to-be-confused-with", or
                    "http://syriaca.org/taxonomy/share-a-name".</sch:assert>
                  <sch:assert test="@mutual"> This relationship requires a @mutual attribute.
                  </sch:assert>
                </sch:rule>
                <sch:rule context="tei:text//tei:relation[@type='see-also']">
                  <sch:assert test="@ref='http://syriaca.org/taxonomy/related'"> With
                    @type="see-also", the @ref attribute must be
                    "http://syriaca.org/taxonomy/related".</sch:assert>
                  <sch:assert test="@mutual"> This relationship requires a @mutual attribute.
                  </sch:assert>
                </sch:rule>
                <sch:rule context="tei:text//tei:relation[@type='contained-within']">
                  <sch:assert test="@ref='http://syriaca.org/taxonomy/broader'"> With
                    @type="contained-within", the @ref attribute must be
                    "http://syriaca.org/taxonomy/broader".</sch:assert>
                  <sch:assert test="@active and @passive"> This relationship requires
                    @active/@passive attributes. </sch:assert>
                </sch:rule>
                <sch:rule
                  context="tei:text//tei:relation[@ref='http://syriaca.org/taxonomy/conceptually-related']">
                  <sch:assert test="@type='disambiguation'"> This relationship requires
                    @type="disambiguation".</sch:assert>
                </sch:rule>
                <sch:rule
                  context="tei:text//tei:relation[@ref='http://syriaca.org/taxonomy/co-located']">
                  <sch:assert test="@type='disambiguation'"> This relationship requires
                    @type="disambiguation".</sch:assert>
                </sch:rule>
                <sch:rule
                  context="tei:text//tei:relation[@ref='http://syriaca.org/taxonomy/not-to-be-confused-with']">
                  <sch:assert test="@type='disambiguation'"> This relationship requires
                    @type="disambiguation".</sch:assert>
                </sch:rule>
                <sch:rule
                  context="tei:text//tei:relation[@ref='http://syriaca.org/taxonomy/share-a-name']">
                  <sch:assert test="@type='disambiguation'"> This relationship requires
                    @type="disambiguation".</sch:assert>
                </sch:rule>
                <sch:rule
                  context="tei:text//tei:relation[@ref='http://syriaca.org/taxonomy/broader']">
                  <sch:assert test="@type='contained-within'"> This relationship requires
                    @type="contained-within"</sch:assert>
                </sch:rule>
                <sch:rule
                  context="tei:text//tei:relation[@ref='http://syriaca.org/taxonomy/related']">
                  <sch:assert test="@type='disambiguation'"> For a 'related' relationship, use
                    @type="see-also".</sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="type" mode="replace" usage="req">
                <valList type="closed">
                  <valItem ident="disambiguation">
                    <desc>Used for a group of relationships that disambiguate between
                      entities.</desc>
                  </valItem>
                  <valItem ident="contained-within">
                    <desc>Used for a nesting relationship and indicates when are larger entity
                      contains the subject of an authority file.</desc>
                  </valItem>
                  <valItem ident="see-also">
                    <desc>Used when the encoder wants to point user to another entity they may want
                      to see.</desc>
                  </valItem>
                </valList>
              </attDef>
              <attDef ident="subtype" mode="delete">
                <!--<valList type="closed" mode="change">
                <valItem ident="share-a-name">
                  <desc>Used with disambiguation relationships when the entities have the same or a very similar name. 
                    This could either be a situation in which two otherwise unrelated places share a name, i.e. two 
                    churches in different locations with the name "Saint George", or a situation in which a city, 
                    the diocese associated with that city, and the region around that city all share a name.
                  </desc>
                </valItem>
              </valList>-->
              </attDef>
              <attDef ident="ref" mode="replace" usage="req">
                <valList type="closed">
                  <valItem ident="http://syriaca.org/taxonomy/conceptually-related">
                    <desc>Used to indicate when this entity is closely related conceptually to
                      another entity, i.e. a settlement, its diocese, and its region.</desc>
                  </valItem>
                  <valItem ident="http://syriaca.org/taxonomy/co-located">
                    <desc>Used to indicate when distinct entities share a location and therefore
                      might be confused.</desc>
                  </valItem>
                  <valItem ident="http://syriaca.org/taxonomy/not-to-be-confused-with">
                    <desc>Used to distinguish between entities that have been confused in the
                      scholarly literature or might be confused by users.</desc>
                  </valItem>
                  <valItem ident="http://syriaca.org/taxonomy/possibly-identical">
                    <desc>Used to indicate that even though Syriaca.org has identified this location
                      as a distinct entity, it is possible that this place is the same an another
                      entity.</desc>
                  </valItem>
                  <valItem ident="http://syriaca.org/taxonomy/share-a-name">
                    <desc>Used to indicate when entities share a name but remain distinct; i.e. when
                      different settlements or churches share a name.</desc>
                  </valItem>
                  <valItem ident="http://syriaca.org/taxonomy/broader">
                    <desc>Used for a nesting relationship and indicates when a larger entity
                      contains the subject of this authority file.</desc>
                  </valItem>
                  <valItem ident="http://syriaca.org/taxonomy/related">
                    <desc>Used for a "see-also" relationship.</desc>
                  </valItem>
                </valList>
              </attDef>
            </attList>
          </elementSpec>



          <elementSpec ident="seriesStmt" module="header" mode="change">
            <constraintSpec ident="seriesStmt-series" scheme="schematron">
              <constraint>
                <sch:rule context="//tei:seriesStmt/tei:title[@level='s']">
                  <sch:assert
                    test="./node() = 'The Syriac Gazetteer' or ./node() = 'A Guide to John of Ephesus'"
                    > This &lt;title&gt; element must be "The Syriac Gazetteer" or "A Guide to John
                    of Ephesus". </sch:assert>
                </sch:rule>
                <sch:rule context="//tei:seriesStmt[tei:title = 'The Syriac Gazetteer']/tei:idno">
                  <sch:assert test="matches(., 'http://syriaca.org/geo')"> This &lt;idno&gt; element
                    must contain "http://syriaca.org/geo". </sch:assert>
                </sch:rule>
                <sch:rule
                  context="//tei:seriesStmt[tei:title = 'A Guide to John of Ephesus']/tei:idno">
                  <sch:assert test="matches(., 'http://syriaca.org/johnofephesus')"> This
                    &lt;idno&gt; element must contain "http://syriaca.org/johnofephesus".
                  </sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="seriesStmt-monograph" scheme="schematron">
              <constraint>
                <sch:rule context="//tei:seriesStmt/tei:title[@level='m']">
                  <sch:assert
                    test="./node() = 'Beth Qaṭraye Gazetteer' or ./node() = 'Gazetteer to John of Ephesus’s Ecclesiastical History'"
                    > This &lt;title&gt; element must be "Beth Qaṭraye Gazetteer" or "Gazetteer to
                    John of Ephesus’s Ecclesiastical History". </sch:assert>
                </sch:rule>
                <sch:rule context="//tei:seriesStmt[tei:title='Beth Qaṭraye Gazetteer']/tei:idno">
                  <sch:assert test="matches(., 'http://syriaca.org/bethqatraye')"> This &lt;idno&gt;
                    element must be "http://syriaca.org/bethqatraye". </sch:assert>
                </sch:rule>
                <sch:rule context="//tei:seriesStmt[tei:title='Beth Qaṭraye Gazetteer']">
                  <sch:assert test="tei:biblScope/@n = '1'"> Requires a &lt;biblScope&gt; element
                    with @n="1" since the "Beth Qaṭraye Gazetteer" is volume 1 of "The Syriac
                    Gazetteer". </sch:assert>
                </sch:rule>
                <sch:rule
                  context="//tei:seriesStmt[tei:title='Gazetteer to John of Ephesus’s Ecclesiastical History']/tei:idno">
                  <sch:assert test="matches(., 'http://syriaca.org/johnofephesus/places')"> This
                    &lt;idno&gt; element must be "http://syriaca.org/johnofephesus/places".
                  </sch:assert>
                </sch:rule>
                <sch:rule
                  context="//tei:seriesStmt[tei:title='Gazetteer to John of Ephesus’s Ecclesiastical History']">
                  <sch:assert test="tei:biblScope/@n = '2'"> Requires a &lt;biblScope&gt; element
                    with @n="2" since the "Gazetteer to John of Ephesus’s Ecclesiastical History" is
                    volume 2 of "The Syriac Gazetteer". </sch:assert>
                </sch:rule>
              </constraint>
            </constraintSpec>
          </elementSpec>




          <elementSpec ident="state" module="namesdates" mode="change">
            <constraintSpec ident="xmlID-on-state" scheme="schematron">
              <constraint> </constraint>
            </constraintSpec>
            <constraintSpec ident="state-type-existence" scheme="schematron">
              <constraint>
                <sch:rule context="//tei:place/tei:state[@type='existence']">
                  <sch:assert test="attribute::source or attribute::resp"> Must have either a
                    @source attribute (preferred when available) or a @resp attribute. </sch:assert>
                  <sch:report test="attribute::source and attribute::resp"> Not allowed to take both
                    a @source attribute (the preferred when available) and a @resp attribute. </sch:report>
                  <sch:report test="@xml:id"> An @xml:id attribute not allowed here. </sch:report>
                  <sch:report test="@ref"> A @ref attribute not allowed here. </sch:report>
                </sch:rule>
              </constraint>
            </constraintSpec>
            <constraintSpec ident="state-type-confession" scheme="schematron">
              <constraint>
                <sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:ns uri="http://www.w3.org/1999/02/22-rdf-syntax-ns#" prefix="rdf"/>
                  <sch:ns uri="http://www.w3.org/2004/02/skos/core#" prefix="skos"/>
                  <sch:pattern>
                    <sch:rule context="tei:text//tei:state[@type='confession']">
                      <sch:let name="docURIno"
                        value="replace(//tei:publicationStmt/tei:idno[@type='URI'][not(@type='deprecated')]/text(), '.+?(\d+).+', '$1')"/>
                      <sch:let name="id" value="@xml:id"/>
                      <sch:assert test="@ref">Must have a @ref attribute.</sch:assert>
                      <sch:assert
                        test="matches(./@xml:id, concat('confession', $docURIno, '-', '\d+$'))"> The
                        required @xml:id must be 'confession<sch:value-of select="$docURIno"
                        />-{\d+$}' (where {\d+$} is a number). </sch:assert>
                      <sch:report test="preceding-sibling::element()[@xml:id = $id]">This @xml:id is
                        already in use.</sch:report>
                    </sch:rule>
                    <sch:rule context="tei:state[@type='confession']/@ref">
                      <sch:let name="refTokens" value="tokenize(., ' ')"/>
                      <sch:let name="taxonomy"
                        value="doc('https://raw.githubusercontent.com/srophe/syriaca-data/refs/heads/gaddel_development/data/taxonomy/taxonomy.rdf')"/>
                      <sch:let name="religionURIs"
                        value="$taxonomy//rdf:Description[@rdf:about='http://syriaca.org/taxonomy/religious-communities-collection']/skos:member/@rdf:resource"/>
                      <sch:let name="errors"
                        value="for $i in $refTokens return $i[not(. = $religionURIs)]"/>
                      <sch:assert test="every $i in $refTokens satisfies $i = $religionURIs"
                        role="warning">
                        <sch:value-of select="string-join($errors, ', ')"/>: URI(s) not the
                        religious communities in the Taxonomy. If you find no appropriate concept on
                        the following list, please choose a keyword of your own for the editors to
                        consider: <sch:value-of select="string-join($religionURIs, ';  ')"
                        />.</sch:assert>
                    </sch:rule>
                  </sch:pattern>
                </sch:schema>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="type" mode="change" usage="req">
                <valList type="closed" mode="change">
                  <valItem ident="confession">
                    <desc>identifies the presence of a confessional community in this place</desc>
                  </valItem>
                  <valItem ident="existence">
                    <desc>indicates that the place existed</desc>
                  </valItem>
                </valList>
              </attDef>
            </attList>
          </elementSpec>




        </schemaSpec>
      </div>
    </body>
  </text>
</TEI>
